<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · EquationDemoLib.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>EquationDemoLib.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Experiments"><span>Experiments</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PeterLarochkin/EquationDemoLib/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="EquationDemoLib.jl"><a class="docs-heading-anchor" href="#EquationDemoLib.jl">EquationDemoLib.jl</a><a id="EquationDemoLib.jl-1"></a><a class="docs-heading-anchor-permalink" href="#EquationDemoLib.jl" title="Permalink"></a></h1><h2 id="Experiments"><a class="docs-heading-anchor" href="#Experiments">Experiments</a><a id="Experiments-1"></a><a class="docs-heading-anchor-permalink" href="#Experiments" title="Permalink"></a></h2><p>This library compares the compilation and evaluation speeds of two identical programs. Results are shown below.</p><pre><code class="language-bash hljs">\# Juila program
n:0, diff:0.0306972956
n:1000, diff:0.0029081786
n:2000, diff:0.0009298924
n:3000, diff:0.0003381923
n:4000, diff:0.0001284034
n:5000, diff:0.0000494494
n:6000, diff:0.0000191328
n:7000, diff:0.0000074143
n:8000, diff:0.0000028746
n:9000, diff:0.0000011147
total count:9117
diff:0.0006959054
Elapsed time: 5.566 seconds
</code></pre><pre><code class="language-bash hljs">\# C program
n:0, diff:0.0306972956
n:1000, diff:0.0029081786
n:2000, diff:0.0009298924
n:3000, diff:0.0003381923
n:4000, diff:0.0001284034
n:5000, diff:0.0000494494
n:6000, diff:0.0000191328
n:7000, diff:0.0000074143
n:8000, diff:0.0000028746
n:9000, diff:0.0000011147
total count: 9117
diff:0.0006959054
Elapsed time: 5.85 seconds</code></pre><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationDemoLib.q" href="#EquationDemoLib.q"><code>EquationDemoLib.q</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q(x::Float64, y::Float64)::Float64</code></pre><p>This function calculates the sum of two floating-point numbers <code>x</code> and <code>y</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Float64</code>: The first number.</li><li><code>y::Float64</code>: The second number.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The sum of <code>x</code> and <code>y</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PeterLarochkin/EquationDemoLib/blob/e378067144db29303d56798c723335d415f31ef3/src/EquationDemoLib.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationDemoLib.u" href="#EquationDemoLib.u"><code>EquationDemoLib.u</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">u(x::Float64, y::Float64) -&gt; Float64</code></pre><p>Calculates the analytical solution for a given experiment based on the input values <code>x</code> and <code>y</code>. </p><p>The function computes the square root of the sum of 4.0 and the product of <code>x</code> and <code>y</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Float64</code>: A floating-point number representing the first input parameter.</li><li><code>y::Float64</code>: A floating-point number representing the second input parameter.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The result of the analytical calculation, which is the square root of the sum of 4.0 and <code>x*y</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PeterLarochkin/EquationDemoLib/blob/e378067144db29303d56798c723335d415f31ef3/src/EquationDemoLib.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationDemoLib.F" href="#EquationDemoLib.F"><code>EquationDemoLib.F</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">F(x::Float64, y::Float64) -&gt; Float64</code></pre><p>Computes the right part of the equation for the experiment. The function calculates a specific value based on the input parameters <code>x</code> and <code>y</code>, which involves an analytical expression.</p><p>The function performs the following steps:</p><ol><li>Computes the intermediate value <code>u</code> as the square root of <code>4.0 + x * y</code>.</li><li>Uses <code>u</code> to compute the final result, which is the sum of two terms:<ul><li>The first term is <span>$(\frac{x^2 + y^2}{4u^3})$</span>.</li><li>The second term is <span>$((x + y) \cdot u)$</span>.</li></ul></li></ol><p><strong>Arguments</strong></p><ul><li><code>x::Float64</code>: A floating-point number representing the first input parameter.</li><li><code>y::Float64</code>: A floating-point number representing the second input parameter.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The computed result of the right part of the equation, which combines the contributions from <code>x</code> and <code>y</code> and the intermediate value <code>u</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PeterLarochkin/EquationDemoLib/blob/e378067144db29303d56798c723335d415f31ef3/src/EquationDemoLib.jl#L39-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationDemoLib.psi" href="#EquationDemoLib.psi"><code>EquationDemoLib.psi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">psi(x::Float64, y::Float64, A1::Float64, A2::Float64, B1::Float64, B2::Float64, h1::Float64, h2::Float64) -&gt; Float64</code></pre><p>Defines the boundary values for a specific rectangular area. The function calculates the value at the boundary of the rectangular domain based on the input parameters. </p><p>The function handles various edge cases of the rectangle defined by corners (A1, B1), (A2, B1), (A2, B2), and (A1, B2), and computes values based on different conditions:</p><ol><li><p><strong>Vertical edges:</strong></p><ul><li>For (x = A2 and (B1 &lt; y &lt; B2, it uses the function <code>u(x, y)</code> to compute the boundary value.</li><li>For (x = A1 and (B1 &lt; y &lt; B2, it returns -y/4 + 2.</li></ul></li><li><p><strong>Horizontal edges:</strong></p><ul><li>For y = B2 and A1 &lt; x &lt; A2, it uses the function <code>u(x, y)</code> to compute the boundary value.</li><li>For y = B1 and A1 &lt; x &lt; A2, it returns -x/4 + 2.</li></ul></li><li><p><strong>Corners:</strong></p><ul><li>For (x, y) = (A1, B1), it returns a weighted average of boundary values at (A1, B1).</li><li>For (x, y) = (A1, B2), it returns a weighted average of boundary values at (A1, B2).</li><li>For (x, y) = (A2, B1), it returns a weighted average of boundary values at (A2, B1).</li><li>For (x, y) = (A2, B2), it returns a weighted average of boundary values at (A2, B2).</li></ul></li></ol><p><strong>Arguments</strong></p><ul><li><code>x::Float64</code>: The x-coordinate of the point.</li><li><code>y::Float64</code>: The y-coordinate of the point.</li><li><code>A1::Float64</code>: The x-coordinate of the left boundary of the rectangle.</li><li><code>A2::Float64</code>: The x-coordinate of the right boundary of the rectangle.</li><li><code>B1::Float64</code>: The y-coordinate of the bottom boundary of the rectangle.</li><li><code>B2::Float64</code>: The y-coordinate of the top boundary of the rectangle.</li><li><code>h1::Float64</code>: A weighting factor for the boundary values.</li><li><code>h2::Float64</code>: A weighting factor for the boundary values.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The computed boundary value at the point (x, y).</li></ul><p><strong>Throws</strong></p><ul><li>Throws an <code>ErrorException</code> if the point (x, y) is not on the boundary of the rectangle defined by [A1, A2] 	imes [B1, B2].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PeterLarochkin/EquationDemoLib/blob/e378067144db29303d56798c723335d415f31ef3/src/EquationDemoLib.jl#L61-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationDemoLib.apply_A" href="#EquationDemoLib.apply_A"><code>EquationDemoLib.apply_A</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_A(matrix_apply_to::Matrix{Float64}, A1::Float64, A2::Float64, B1::Float64, B2::Float64, h1::Float64, h2::Float64) -&gt; Matrix{Float64}</code></pre><p>Applies a specific operator <code>A</code> to a given matrix. The operator is defined for the boundary conditions of a rectangular domain. This function returns a new matrix that is the result of applying the operator <code>A</code> to the input matrix <code>matrix_apply_to</code>, based on the specified boundaries and weighting factors.</p><p>The function iterates over each element of the input matrix and applies the operator <code>A</code> based on the position of the element relative to the boundaries of the rectangular domain.</p><p><strong>Arguments</strong></p><ul><li><code>matrix_apply_to::Matrix{Float64}</code>: The matrix to which the operator <code>A</code> will be applied. The function returns a new matrix with the results.</li><li><code>A1::Float64</code>: The x-coordinate of the left boundary of the rectangular domain.</li><li><code>A2::Float64</code>: The x-coordinate of the right boundary of the rectangular domain.</li><li><code>B1::Float64</code>: The y-coordinate of the bottom boundary of the rectangular domain.</li><li><code>B2::Float64</code>: The y-coordinate of the top boundary of the rectangular domain.</li><li><code>h1::Float64</code>: A weighting factor used in the operator <code>A</code>.</li><li><code>h2::Float64</code>: Another weighting factor used in the operator <code>A</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A new matrix with the operator <code>A</code> applied, based on the boundary conditions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PeterLarochkin/EquationDemoLib/blob/e378067144db29303d56798c723335d415f31ef3/src/EquationDemoLib.jl#L123-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationDemoLib.get_B" href="#EquationDemoLib.get_B"><code>EquationDemoLib.get_B</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_B(M::Int, N::Int, h1::Float64, h2::Float64, A1::Float64, A2::Float64, B1::Float64, B2::Float64) -&gt; Matrix{Float64}</code></pre><p>Generates a matrix <code>B</code> based on the boundary conditions of a rectangular domain. The matrix <code>B</code> is computed by applying either the <code>psi</code> function (for boundary edges) or the <code>F</code> function (for interior points) based on the location of each matrix element relative to the defined boundaries.</p><p>The function initializes a matrix of size <code>M</code> by <code>N</code>, where each element is computed as follows:</p><ul><li><strong>Edges</strong>: For elements on the boundary of the rectangular domain, the function uses the <code>psi</code> function to determine the value.</li><li><strong>Interior</strong>: For elements inside the boundary, the function uses the <code>F</code> function.</li></ul><p><strong>Arguments</strong></p><ul><li><code>M::Int</code>: Number of rows in the resulting matrix.</li><li><code>N::Int</code>: Number of columns in the resulting matrix.</li><li><code>h1::Float64</code>: Weighting factor for the boundary conditions.</li><li><code>h2::Float64</code>: Another weighting factor for the boundary conditions.</li><li><code>A1::Float64</code>: The x-coordinate of the left boundary of the rectangular domain.</li><li><code>A2::Float64</code>: The x-coordinate of the right boundary of the rectangular domain.</li><li><code>B1::Float64</code>: The y-coordinate of the bottom boundary of the rectangular domain.</li><li><code>B2::Float64</code>: The y-coordinate of the top boundary of the rectangular domain.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A matrix of size <code>M</code> by <code>N</code> with values computed using the <code>psi</code> or <code>F</code> functions based on boundary conditions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PeterLarochkin/EquationDemoLib/blob/e378067144db29303d56798c723335d415f31ef3/src/EquationDemoLib.jl#L207-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationDemoLib.scalar_product" href="#EquationDemoLib.scalar_product"><code>EquationDemoLib.scalar_product</code></a> — <span class="docstring-category">Function</span></header><section><div><p>scalar_product(A::Matrix{Float64}, B::Matrix{Float64}, h1::Float64, h2::Float64) -&gt; Float64</p><p>Computes the scalar product of two matrices <code>A</code> and <code>B</code> by performing element-wise multiplication and then summing the results. The function uses weighting factors <code>h1</code> and <code>h2</code> to adjust the product based on the index of each element.</p><p>The scalar product is computed as follows:</p><ol><li>For each element <code>(i, j)</code> in the matrices <code>A</code> and <code>B</code>, compute the product <code>A[i, j] * B[i, j]</code>.</li><li>Apply a weight based on the indices <code>(i, j)</code> using the parameters <code>h1</code> and <code>h2</code>.</li><li>Sum all the weighted products to obtain the final scalar result.</li></ol><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{Float64}</code>: The first matrix for the scalar product calculation.</li><li><code>B::Matrix{Float64}</code>: The second matrix for the scalar product calculation.</li><li><code>h1::Float64</code>: A weighting factor used in the computation.</li><li><code>h2::Float64</code>: Another weighting factor used in the computation.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The scalar result of the element-wise product of <code>A</code> and <code>B</code>, weighted by <code>h1</code> and <code>h2</code>, and summed.  scalar_product(A::Matrix{Float64}, B::Matrix{Float64}, h1::Float64, h2::Float64) -&gt; Float64</li></ul><p>Computes the scalar product of two matrices <code>A</code> and <code>B</code> by performing element-wise multiplication and then summing the results. The function uses weighting factors <code>h1</code> and <code>h2</code> to adjust the product based on the index of each element.</p><p>The scalar product is computed as follows:</p><ol><li>For each element <code>(i, j)</code> in the matrices <code>A</code> and <code>B</code>, compute the product <code>A[i, j] * B[i, j]</code>.</li><li>Apply a weight based on the indices <code>(i, j)</code> using the parameters <code>h1</code> and <code>h2</code>.</li><li>Sum all the weighted products to obtain the final scalar result.</li></ol><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{Float64}</code>: The first matrix for the scalar product calculation.</li><li><code>B::Matrix{Float64}</code>: The second matrix for the scalar product calculation.</li><li><code>h1::Float64</code>: A weighting factor used in the computation.</li><li><code>h2::Float64</code>: Another weighting factor used in the computation.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The scalar result of the element-wise product of <code>A</code> and <code>B</code>, weighted by <code>h1</code> and <code>h2</code>, and summed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PeterLarochkin/EquationDemoLib/blob/e378067144db29303d56798c723335d415f31ef3/src/EquationDemoLib.jl#L278-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationDemoLib.proximity_search" href="#EquationDemoLib.proximity_search"><code>EquationDemoLib.proximity_search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">proximity_search(M::Int, N::Int)</code></pre><p>Performs an iterative search to solve a given problem using an iterative method to update the solution based on residuals. This function iteratively refines the approximation <code>omega</code> to minimize the residual between <code>A * omega</code> and <code>B</code> until the change between successive iterations is below a specified tolerance.</p><p>The function performs the following steps:</p><ol><li>Initializes the parameters, matrices, and iteration variables.</li><li>Computes the initial matrix <code>B</code> using boundary conditions.</li><li>Iteratively updates the solution <code>omega</code> using the following formula: $ \omega<em>{ij}^{(k+1)} = \omega</em>{ij}^{(k)} - \tau<em>{k+1} r</em>{ij}^{(k)} $ where the residual <span>$r^{(k)}$</span> is calculated as <span>$r^{(k)} = A \omega^{(k)} - B$</span> and the iteration parameter <span>$\tau_{k+1}$</span> is computed as: $ \tau<em>{k+1} = \frac{[A r^{(k)}, r^{(k)}]}{||A r^{(k)}||</em>{E}^{2}} $</li><li>Stops the iteration when the change between successive iterations is less than the specified tolerance <span>$\varepsilon$</span>.</li><li>Outputs the number of iterations and the maximum difference between the computed solution and the analytical solution.</li></ol><p><strong>Arguments</strong></p><ul><li><code>M::Int</code>: Number of rows in the matrix for the problem.</li><li><code>N::Int</code>: Number of columns in the matrix for the problem.</li></ul><p><strong>Returns</strong></p><ul><li>None: The function prints the iteration results and maximum difference to the console.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PeterLarochkin/EquationDemoLib/blob/e378067144db29303d56798c723335d415f31ef3/src/EquationDemoLib.jl#L332-L354">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 22 July 2024 12:21">Monday 22 July 2024</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
